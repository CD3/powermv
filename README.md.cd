# A powerful renaming utility

<!-- {{{ -->
<!-- import pathlib -->
<!-- def include_filter(filename): -->
<!--   return pathlib.Path(filename).read_text() -->
<!-- -->
<!-- jinja2_env.filters['include'] = include_filter -->
<!-- }}} -->

## Features

- Rename multiple files and/or directories at once (batch rename).
- Automatically create parent directories for renamed files.
- Use regex capture groups to extract parts of the input file name to be used in the output filename.
- Use jinja2 templates to render output filename.
    - Use filters to increment enumerations, add padding, etc.
- Easily increment an integer value in the filename of a set of files. i.e. (rename file-1.txt to file-2.txt)
- _All_ actions are analyzed to detect errors (missing inputs, output name
  collisions, overwriting files) _before_ making any changes. If _any_ error is detected,
  no actions are executed.
    - Multiple input files being renamed to the same output file is an _error_ unless the output is a directory.
    - Files that would be renamed to an existing file that is not one of the
      input files to be renamed is an _error_ unless the --overwrite option is
      given.
    - Input files that do not exist is an _error_.
    - Input files that appear multiple times is an __error_.
- Match full path, just the name, or a portion of either.

## Motivation

Why another batch renaming tool?

PowerMV has goals similar to

- [rnr](https://github.com/ismaelgv/rnr)
- [nomino](https://github.com/yaa110/nomino)
- [brename](https://github.com/shenwei356/brename)
- [rename](https://metacpan.org/pod/rename)
- [rnm](https://github.com/neurobin/rnm)

Of these utilities, I have used `rename` the most, and recently started using `rnr`.
Both tools are nice and work for 99% of my use cases. However, there is one specfic use
case that I occationally have when working with files created by/for some physics
simulation or demos for [Phys 312
class](https://hostcat.fhsu.edu/cdclark/website.fcgi/classes/Phys_312), and that is
batch renaming with increment/decrement of integers in the filename. For example, say
I have some demo files:

```bash
$ ls
01-text_files.sh
02-text_editors.sh
03-file_redirection.sh
```

I have these files named so that they will be loaded (by my [pygsc](https://github.com/CD3/pygsc) utility)
in order. Now say I want to add a demo at the beginning of the tutorial for some
preliminary stuff. I create a filed named `01-preliminaries.sh`. But before I do, I
would like to rename all of the existing scripts to increment their index:

```bash
01-text_files.sh       -> 02-text_files.sh
02-text_editors.sh     -> 03-text_editors.sh
03-file_redirection.sh -> 04-file_redirection.sh
```

I would like to have way to do this rename automatically. There are some tools (like
[ranger](https://github.com/ranger/ranger)) that allow you to do batch renaming and edit
the file rename operations in a text file, so you can use vim's ctl-a and ctl-x to help
do the rename quickly. However, there are some situations that you need to be careful
with.

Let say I have a set of enumerated input configuration files.

```bash
$ ls
config-01.yml
config-02.yml
config-03.yml
config-04.yml
config-05.yml
```

If I want to rename these to

```bash
$ ls
config-02.yml
config-03.yml
config-04.yml
config-05.yml
config-06.yml
```

there is a possibility that I will accidentally delete files. If `config-01.yml` gets
renamed to `config-02.yml` _first_, then when `config-02.yml` is renamed to
`config-03.yml`, it will actually be a copy of the original `config-01.yml`. If all
operations go in order, you will end up with one file.

```bash
$ ls
config-06.yml
```

where the contents of `config-06.yml` will be the contents of the original
`config-01.yml`. Clearly not what was intended.

PowerMV aims to address these problems and make file renaming with
incremented/decremented enumeration indecies possible and easy.

## Install

You can install PowerMV with `pip`, `pipx`, `uv`, or your favorite Python package manger.

```bash
$ pip install powermv
```

```bash
$ pipx install powermv
```

```bash
$ uv tool install powermv
```

## Usage

```bash
{{"doc/examples/help.t"|include}}
```


## Examples

### Rename a series of files that are enumerated, incrementing the enumeration by one.

The original motivation for PowerMV...

```bash
{{"doc/examples/inc_rename.t"|include}}
```

A couple of things to note. First, PowerMV does not do anything by default. All
move operations are created, analyzed, ordered, and displayed, but nothing
happens. If you want to execute the move operations, you give the `-x` option
(alias for `--execute`). Second, note how PowerMV has ordered the move
operations so that `file-3.txt` gets moved _before_ `file-2.txt` get moved to
`file-3.txt`. If PowerMV detects that a file will be renamed to a file that is
also going to be renamed, it will make sure that latter happens first.

### Rename enumerated files, incrementing enumeration by two.

```bash
{{"doc/examples/inc_by_two.t"|include}}
```

### Rename enumerated files, decrementing enumeration by one.

```bash
{{"doc/examples/inc_rename.t"|include}}
```

### Rename enumerated files to increase the padding used in the enumeration.

```bash
{{"doc/examples/pad_rename.t"|include}}
```

### Move files into their own directories.

```bash
{{"doc/examples/move_files_to_dir_with_idx.t"|include}}
```

### Match files to move using a part of the full path, a part of the file name, or the full filename.

```bash
{{"doc/examples/full_vs_partial_matches.t"|include}}
```


## How it works

PowerMV builds a set of "move operations" that need to be executed. Each move operation consists of an "input" (a file/directory
that exists and should be renamed/moved) and an "output" (a file/directory that the input will be moved to). The move operation set
is built using a "match pattern", a "replace template", and a list of files. All are passed as arguments.

Files that should not be renamed can be passed as arguments. Only files that match the _match pattern_ will be renamed. This is useful
because you can just use a `*` to pass all files in the current directory, and only the files matching the _match pattern_ are
added to the move operation set (just like the `rename` command). 

To build the move operation set, PowerMV check that a file matches the _match pattern_. If it does match, then the _replacement text_
is rendered using the _replacement template_ (a Jinja2 template). PowerMV automatically creates a context for the _replacement template_
from the _match pattern_. Named capture groups are injected into the template as variables with the capture group name. Unnamed
capture groups are injected into the template as variables named by the capture group index. The first unnamed capture group will be
named `_1`, the second `_2`, etc.

More to come...
